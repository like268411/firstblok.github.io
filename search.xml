<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>15道ES6 Promise实战练习题</title>
      <link href="/2022/05/15/15-dao-es6-promise-shi-zhan-lian-xi-ti/"/>
      <url>/2022/05/15/15-dao-es6-promise-shi-zhan-lian-xi-ti/</url>
      
        <content type="html"><![CDATA[<p>Promise 是 ES6 中的特性，现在很多前端框架像 AngularJS，Vue 等在 HTTP 请求之后都是返回的 Promise 处理,因此 Promise 是必须要掌握的一个知识点。</p><p>本文将为大家分享 15 道由易到难的 ES6 Promise 题, 帮助你快速理解 Promise。</p><hr><h2 id="基础题"><a href="#基础题" class="headerlink" title="基础题"></a>基础题</h2><hr><h3 id="01"><a href="#01" class="headerlink" title="01"></a>01</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; {</span><br><span class="line">    console.log(1)</span><br><span class="line">    resolve()</span><br><span class="line">    console.log(2)</span><br><span class="line">})</span><br><span class="line">promise.then(() =&gt; {</span><br><span class="line">    console.log(3)</span><br><span class="line">})</span><br><span class="line">console.log(4)</span><br></pre></td></tr></tbody></table></figure><p>解析：</p><p>Promise 构造函数是同步执行的，promise.then 中的函数是异步执行的。</p><p>运行结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// =&gt; 1</span><br><span class="line">// =&gt; 2</span><br><span class="line">// =&gt; 4</span><br><span class="line">// =&gt; 3</span><br></pre></td></tr></tbody></table></figure><h3 id="02"><a href="#02" class="headerlink" title="02"></a>02</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const first = () =&gt; (new Promise((resolve, reject) =&gt; {</span><br><span class="line">    console.log(3);</span><br><span class="line">    let p = new Promise((resolve, reject) =&gt; {</span><br><span class="line">        console.log(7);</span><br><span class="line">        setTimeout(() =&gt; {</span><br><span class="line">            console.log(5);</span><br><span class="line">            resolve(6);</span><br><span class="line">        }, 0)</span><br><span class="line">        resolve(1);</span><br><span class="line">    });</span><br><span class="line">    resolve(2);</span><br><span class="line">    p.then((arg) =&gt; {</span><br><span class="line">        console.log(arg);</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">}));</span><br><span class="line"></span><br><span class="line">first().then((arg) =&gt; {</span><br><span class="line">    console.log(arg);</span><br><span class="line">});</span><br><span class="line">console.log(4);</span><br></pre></td></tr></tbody></table></figure><p>解析：</p><p>这道题主要理解 js 执行机制。</p><p>第一轮事件循环，先执行宏任务，主 script，new Promise 立即执行，输出 3，执行 p 这个 new Promise 操作，输出 7，发现 setTimeout，将回调函数放入下一轮任务队列（Event Quene），p 的 then，暂且命名为 then1，放入微任务队列，且 first 也有 then，命名为 then2，放入微任务队列。执行 console.log(4),输出 4，宏任务执行结束。</p><p>再执行微任务，执行 then1,输出 1，执行 then2,输出 3.</p><p>第一轮事件循环结束，开始执行第二轮。第二轮事件循环先执行宏任务里面的，也就是 setTimeout 的回调，输出 5.resolve(6)不会生效，因为 p 的 Promise 状态一旦改变就不会再变化了。</p><p>运行结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// =&gt; 3</span><br><span class="line">// =&gt; 7</span><br><span class="line">// =&gt; 4</span><br><span class="line">// =&gt; 1</span><br><span class="line">// =&gt; 2</span><br><span class="line">// =&gt; 5</span><br></pre></td></tr></tbody></table></figure><h3 id="03"><a href="#03" class="headerlink" title="03"></a>03</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const promise1 = new Promise((resolve, reject) =&gt; {</span><br><span class="line">  setTimeout(() =&gt; {</span><br><span class="line">    resolve('success')</span><br><span class="line">  }, 1000)</span><br><span class="line">})</span><br><span class="line">const promise2 = promise1.then(() =&gt; {</span><br><span class="line">  throw new Error('error!!!')</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">console.log('promise1', promise1)</span><br><span class="line">console.log('promise2', promise2)</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; {</span><br><span class="line">  console.log('promise1', promise1)</span><br><span class="line">  console.log('promise2', promise2)</span><br><span class="line">}, 2000)</span><br></pre></td></tr></tbody></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">promise1 Promise {&lt;pending&gt;}</span><br><span class="line">promise2 Promise {&lt;pending&gt;}</span><br><span class="line">Uncaught (in promise) Error: error!!!</span><br><span class="line">    at &lt;anonymous&gt;</span><br><span class="line">promise1 Promise {&lt;resolved&gt;: "success"}</span><br><span class="line">promise2 Promise {&lt;rejected&gt;: Error: error!!!</span><br><span class="line">    at &lt;anonymous&gt;}</span><br></pre></td></tr></tbody></table></figure><p>解释：promise 有 3 种状态：pending、fulfilled 或 rejected。状态改变只能是 pending-&gt;fulfilled 或者 pending-&gt;rejected，状态一旦改变则不能再变。上面 promise2 并不是 promise1，而是返回的一个新的 Promise 实例。</p><h3 id="04"><a href="#04" class="headerlink" title="04"></a>04</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; {</span><br><span class="line">  resolve('success1')</span><br><span class="line">  reject('error')</span><br><span class="line">  resolve('success2')</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">  .then((res) =&gt; {</span><br><span class="line">    console.log('then: ', res)</span><br><span class="line">  })</span><br><span class="line">  .catch((err) =&gt; {</span><br><span class="line">    console.log('catch: ', err)</span><br><span class="line">  })</span><br></pre></td></tr></tbody></table></figure><p>解析：</p><p>构造函数中的 resolve 或 reject 只有第一次执行有效，多次调用没有任何作用，呼应代码二结论：promise 状态一旦改变则不能再变。</p><p>运行结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">then: success1</span><br></pre></td></tr></tbody></table></figure><h3 id="05"><a href="#05" class="headerlink" title="05"></a>05</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(1)</span><br><span class="line">  .then((res) =&gt; {</span><br><span class="line">    console.log(res)</span><br><span class="line">    return 2</span><br><span class="line">  })</span><br><span class="line">  .catch((err) =&gt; {</span><br><span class="line">    return 3</span><br><span class="line">  })</span><br><span class="line">  .then((res) =&gt; {</span><br><span class="line">    console.log(res)</span><br><span class="line">  })</span><br></pre></td></tr></tbody></table></figure><p>解析：</p><p>promise 可以链式调用。提起链式调用我们通常会想到通过 return this 实现，不过 Promise 并不是这样实现的。promise 每次调用 .then 或者 .catch 都会返回一个新的 promise，从而实现了链式调用。</p><p>运行结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></tbody></table></figure><h3 id="06"><a href="#06" class="headerlink" title="06"></a>06</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; {</span><br><span class="line">  setTimeout(() =&gt; {</span><br><span class="line">    console.log('once')</span><br><span class="line">    resolve('success')</span><br><span class="line">  }, 1000)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">const start = Date.now()</span><br><span class="line">promise.then((res) =&gt; {</span><br><span class="line">  console.log(res, Date.now() - start)</span><br><span class="line">})</span><br><span class="line">promise.then((res) =&gt; {</span><br><span class="line">  console.log(res, Date.now() - start)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>解析：</p><p>promise 的 .then 或者 .catch 可以被调用多次，但这里 Promise 构造函数只执行一次。或者说 promise 内部状态一经改变，并且有了一个值，那么后续每次调用 .then 或者 .catch 都会直接拿到该值。</p><p>运行结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">once</span><br><span class="line">success 1005</span><br><span class="line">success 1007</span><br></pre></td></tr></tbody></table></figure><h3 id="07"><a href="#07" class="headerlink" title="07"></a>07</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve()</span><br><span class="line">  .then(() =&gt; {</span><br><span class="line">    return new Error('error!!!')</span><br><span class="line">  })</span><br><span class="line">  .then((res) =&gt; {</span><br><span class="line">    console.log('then: ', res)</span><br><span class="line">  })</span><br><span class="line">  .catch((err) =&gt; {</span><br><span class="line">    console.log('catch: ', err)</span><br><span class="line">  })</span><br></pre></td></tr></tbody></table></figure><p>解析：</p><p>.then 或者 .catch 中 return 一个 error 对象并不会抛出错误，所以不会被后续的 .catch 捕获，需要改成其中一种：</p><p>return Promise.reject(new Error(‘error!!!’))</p><p>throw new Error(‘error!!!’)</p><p>因为返回任意一个非 promise 的值都会被包裹成 promise 对象，即 return new Error(‘error!!!’) 等价于 return Promise.resolve(new Error(‘error!!!’))。</p><p>运行结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">then:  Error: error!!!</span><br><span class="line">    at &lt;anonymous&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="08"><a href="#08" class="headerlink" title="08"></a>08</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const promise = Promise.resolve()</span><br><span class="line">  .then(() =&gt; {</span><br><span class="line">    return promise</span><br><span class="line">  })</span><br><span class="line">promise.catch(console.error)</span><br></pre></td></tr></tbody></table></figure><p>解析：.then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环。类似于：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">process.nextTick(function tick () {</span><br><span class="line">  console.log('tick')</span><br><span class="line">  process.nextTick(tick)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeError: Chaining cycle detected for promise #&lt;Promise&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="09"><a href="#09" class="headerlink" title="09"></a>09</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(1)</span><br><span class="line">  .then(2)</span><br><span class="line">  .then(Promise.resolve(3))</span><br><span class="line">  .then(console.log)</span><br></pre></td></tr></tbody></table></figure><p>解析：</p><p>.then 或者 .catch 的参数期望是函数，传入非函数则会发生值穿透。</p><p>运行结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></tbody></table></figure><h3 id="10"><a href="#10" class="headerlink" title="10"></a>10</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve()</span><br><span class="line">  .then(function success (res) {</span><br><span class="line">    throw new Error('error')</span><br><span class="line">  }, function fail1 (e) {</span><br><span class="line">    console.error('fail1: ', e)</span><br><span class="line">  })</span><br><span class="line">  .catch(function fail2 (e) {</span><br><span class="line">    console.error('fail2: ', e)</span><br><span class="line">  })</span><br></pre></td></tr></tbody></table></figure><p>解析：</p><p>.then 可以接收两个参数，第一个是处理成功的函数，第二个是处理错误的函数。</p><p>.catch 是 .then 第二个参数的简便写法，但是它们用法上有一点需要注意：.then 的第二个处理错误的函数捕获不了第一个处理成功的函数抛出的错误，而后续的 .catch 可以捕获之前的错误。</p><p>当然以下代码也可以：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve()</span><br><span class="line">  .then(function success1 (res) {</span><br><span class="line">    throw new Error('error')</span><br><span class="line">  }, function fail1 (e) {</span><br><span class="line">    console.error('fail1: ', e)</span><br><span class="line">  })</span><br><span class="line">  .then(function success2 (res) {</span><br><span class="line">  }, function fail2 (e) {</span><br><span class="line">    console.error('fail2: ', e)</span><br><span class="line">  })</span><br></pre></td></tr></tbody></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fail2:  Error: error</span><br><span class="line">    at success (&lt;anonymous&gt;)</span><br></pre></td></tr></tbody></table></figure><h3 id="11"><a href="#11" class="headerlink" title="11"></a>11</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">process.nextTick(() =&gt; {</span><br><span class="line">  console.log('nextTick')</span><br><span class="line">})</span><br><span class="line">Promise.resolve()</span><br><span class="line">  .then(() =&gt; {</span><br><span class="line">    console.log('then')</span><br><span class="line">  })</span><br><span class="line">setImmediate(() =&gt; {</span><br><span class="line">  console.log('setImmediate')</span><br><span class="line">})</span><br><span class="line">console.log('end')</span><br></pre></td></tr></tbody></table></figure><p>解析：</p><p>process.nextTick 和 promise.then 都属于 microtask，而 setImmediate 属于 macrotask，在事件循环的 check 阶段执行。事件循环的每个阶段（macrotask）之间都会执行 microtask，事件循环的开始会先执行一次 microtask。</p><p>运行结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">end</span><br><span class="line">nextTick</span><br><span class="line">then</span><br><span class="line">setImmediate</span><br></pre></td></tr></tbody></table></figure><h2 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h2><hr><p>上面题目太基础，没有挑战性？那就来点有难度的！</p><h3 id="12"><a href="#12" class="headerlink" title="12"></a>12</h3><p>红灯 3 秒亮一次，绿灯 1 秒亮一次，黄灯 2 秒亮一次；如何使用 Promise 让三个灯不断交替重复亮灯？（海康威视笔试题）</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function red(){</span><br><span class="line">    console.log('red');</span><br><span class="line">}</span><br><span class="line">function green(){</span><br><span class="line">    console.log('green');</span><br><span class="line">}</span><br><span class="line">function yellow(){</span><br><span class="line">    console.log('yellow');</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>分析：</p><p>先看题目，题目要求红灯亮过后，绿灯才能亮，绿灯亮过后，黄灯才能亮，黄灯亮过后，红灯才能亮……所以怎么通过 Promise 实现？</p><p>换句话说，就是红灯亮起时，承诺 2s 秒后亮绿灯，绿灯亮起时承诺 1s 后亮黄灯，黄灯亮起时，承诺 3s 后亮红灯……这显然是一个 Promise 链式调用，看到这里你心里或许就有思路了，我们需要将我们的每一个亮灯动作写在 then()方法中，同时返回一个新的 Promise，并将其状态由 pending 设置为 fulfilled，允许下一盏灯亮起。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">function red() {</span><br><span class="line">  console.log('red');</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function green() {</span><br><span class="line">  console.log('green');</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function yellow() {</span><br><span class="line">  console.log('yellow');</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let myLight = (timer, cb) =&gt; {</span><br><span class="line">  return new Promise((resolve) =&gt; {</span><br><span class="line">    setTimeout(() =&gt; {</span><br><span class="line">      cb();</span><br><span class="line">      resolve();</span><br><span class="line">    }, timer);</span><br><span class="line">  });</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let myStep = () =&gt; {</span><br><span class="line">  Promise.resolve().then(() =&gt; {</span><br><span class="line">    return myLight(3000, red);</span><br><span class="line">  }).then(() =&gt; {</span><br><span class="line">    return myLight(2000, green);</span><br><span class="line">  }).then(()=&gt;{</span><br><span class="line">    return myLight(1000, yellow);</span><br><span class="line">  }).then(()=&gt;{</span><br><span class="line">    myStep();</span><br><span class="line">  })</span><br><span class="line">};</span><br><span class="line">myStep();</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// output:</span><br><span class="line">// =&gt; red</span><br><span class="line">// =&gt; green</span><br><span class="line">// =&gt; yellow</span><br><span class="line">// =&gt; red</span><br><span class="line">// =&gt; green</span><br><span class="line">// =&gt; yellow</span><br><span class="line">// =&gt; red</span><br></pre></td></tr></tbody></table></figure><h3 id="13"><a href="#13" class="headerlink" title="13"></a>13</h3><p>请实现一个 mergePromise 函数，把传进去的数组按顺序先后执行，并且把返回的数据先后放到数组 data 中。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">const timeout = ms =&gt; new Promise((resolve, reject) =&gt; {</span><br><span class="line">    setTimeout(() =&gt; {</span><br><span class="line">        resolve();</span><br><span class="line">    }, ms);</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">const ajax1 = () =&gt; timeout(2000).then(() =&gt; {</span><br><span class="line">    console.log('1');</span><br><span class="line">    return 1;</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">const ajax2 = () =&gt; timeout(1000).then(() =&gt; {</span><br><span class="line">    console.log('2');</span><br><span class="line">    return 2;</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">const ajax3 = () =&gt; timeout(2000).then(() =&gt; {</span><br><span class="line">    console.log('3');</span><br><span class="line">    return 3;</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">const mergePromise = ajaxArray =&gt; {</span><br><span class="line">    // 在这里实现你的代码</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">mergePromise([ajax1, ajax2, ajax3]).then(data =&gt; {</span><br><span class="line">    console.log('done');</span><br><span class="line">    console.log(data); // data 为 [1, 2, 3]</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 要求分别输出</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br><span class="line">// done</span><br><span class="line">// [1, 2, 3]</span><br></pre></td></tr></tbody></table></figure><p>分析：</p><p>这道题主要考察用 Promise 控制异步流程，首先 ajax1，ajax2，ajax3 都是函数，只是这些函数执行后会返回一个 Promise，按照题目要求只要顺序执行这三个函数就好了，然后把结果放到 data 中;</p><p>答案：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const mergePromise = ajaxArray =&gt; {</span><br><span class="line">  // 在这里实现你的代码</span><br><span class="line">  // 保存数组中的函数执行后的结果</span><br><span class="line">  var data = [];</span><br><span class="line"></span><br><span class="line">  // Promise.resolve方法调用时不带参数，直接返回一个resolved状态的 Promise 对象。</span><br><span class="line">  var sequence = Promise.resolve();</span><br><span class="line"></span><br><span class="line">  ajaxArray.forEach(item =&gt; {</span><br><span class="line">    // 第一次的 then 方法用来执行数组中的每个函数，</span><br><span class="line">    // 第二次的 then 方法接受数组中的函数执行后返回的结果，</span><br><span class="line">    // 并把结果添加到 data 中，然后把 data 返回。</span><br><span class="line">    sequence = sequence.then(item).then(res =&gt; {</span><br><span class="line">      data.push(res);</span><br><span class="line">      return data;</span><br><span class="line">    });</span><br><span class="line">  });</span><br><span class="line"></span><br><span class="line">// 遍历结束后，返回一个 Promise，也就是 sequence， 他的 [[PromiseValue]] 值就是 data，</span><br><span class="line">// 而 data（保存数组中的函数执行后的结果） 也会作为参数，传入下次调用的 then 方法中。</span><br><span class="line">  return sequence;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="14"><a href="#14" class="headerlink" title="14"></a>14</h3><p>现有 8 个图片资源的 url，已经存储在数组 urls 中，且已有一个函数 function loading，输入一个 url 链接，返回一个 Promise，该 Promise 在图片下载完成的时候 resolve，下载失败则 reject。</p><p>要求：任何时刻同时下载的链接数量不可以超过 3 个。</p><p>请写一段代码实现这个需求，要求尽可能快速地将所有图片下载完成。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var urls = ['https://www.kkkk1000.com/images/getImgData/getImgDatadata.jpg', 'https://www.kkkk1000.com/images/getImgData/gray.gif', 'https://www.kkkk1000.com/images/getImgData/Particle.gif', 'https://www.kkkk1000.com/images/getImgData/arithmetic.png', 'https://www.kkkk1000.com/images/getImgData/arithmetic2.gif', 'https://www.kkkk1000.com/images/getImgData/getImgDataError.jpg', 'https://www.kkkk1000.com/images/getImgData/arithmetic.gif', 'https://www.kkkk1000.com/images/wxQrCode2.png'];</span><br><span class="line"></span><br><span class="line">function loadImg(url) {</span><br><span class="line">    return new Promise((resolve, reject) =&gt; {</span><br><span class="line">        const img = new Image()</span><br><span class="line">        img.onload = () =&gt; {</span><br><span class="line">            console.log('一张图片加载完成');</span><br><span class="line">            resolve();</span><br><span class="line">        }</span><br><span class="line">        img.onerror = reject;</span><br><span class="line">        img.src = url;</span><br><span class="line">    })</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>解析</p><p>题目的意思是需要先并发请求 3 张图片，当一张图片加载完成后，又会继续发起一张图片的请求，让并发数保持在 3 个，直到需要加载的图片都全部发起请求。</p><p>用 Promise 来实现就是，先并发请求 3 个图片资源，这样可以得到 3 个 Promise，组成一个数组 promises，然后不断调用 Promise.race 来返回最快改变状态的 Promise，然后从数组 promises 中删掉这个 Promise 对象，再加入一个新的 Promise，直到全部的 url 被取完，最后再使用 Promise.all 来处理一遍数组 promises 中没有改变状态的 Promise。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function limitLoad(urls, handler, limit) {</span><br><span class="line">  // 对数组做一个拷贝</span><br><span class="line">    const sequence = […urls];</span><br><span class="line"></span><br><span class="line">  let promises = [];</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//并发请求到最大数</span><br><span class="line">  promises = sequence.splice(0, limit).map((url, index) =&gt; {</span><br><span class="line">    // 这里返回的 index 是任务在 promises 的脚标，用于在 Promise.race 之后找到完成的任务脚标</span><br><span class="line">    return handler(url).then(() =&gt; {</span><br><span class="line">      return index;</span><br><span class="line">    });</span><br><span class="line">  });</span><br><span class="line"></span><br><span class="line">  // 利用数组的 reduce 方法来以队列的形式执行</span><br><span class="line">  return sequence.reduce((last, url, currentIndex) =&gt; {</span><br><span class="line">    return last.then(() =&gt; {</span><br><span class="line">      // 返回最快改变状态的 Promise</span><br><span class="line">      return Promise.race(promises)</span><br><span class="line">    }).catch(err =&gt; {</span><br><span class="line">      // 这里的 catch 不仅用来捕获前面 then 方法抛出的错误</span><br><span class="line">      // 更重要的是防止中断整个链式调用</span><br><span class="line">      console.error(err)</span><br><span class="line">    }).then((res) =&gt; {</span><br><span class="line">      // 用新的 Promise 替换掉最快改变状态的 Promise</span><br><span class="line">      promises[res] = handler(sequence[currentIndex]).then(() =&gt; {</span><br><span class="line">        return res</span><br><span class="line">      });</span><br><span class="line">    })</span><br><span class="line">  }, Promise.resolve()).then(() =&gt; {</span><br><span class="line">    return Promise.all(promises)</span><br><span class="line">  })</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">limitLoad(urls, loadImg, 3);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">因为 limitLoad 函数也返回一个 Promise，所以当 所有图片加载完成后，可以继续链式调用</span><br><span class="line"></span><br><span class="line">limitLoad(urls, loadImg, 3).then(() =&gt; {</span><br><span class="line">    console.log('所有图片加载完成');</span><br><span class="line">}).catch(err =&gt; {</span><br><span class="line">    console.error(err);</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h3 id="15"><a href="#15" class="headerlink" title="15"></a>15</h3><p>封装一个异步加载图片的方法</p><p>解析：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function loadImageAsync(url) {</span><br><span class="line">    return new Promise(function(resolve,reject) {</span><br><span class="line">        var image = new Image();</span><br><span class="line">        image.onload = function() {</span><br><span class="line">            resolve(image)</span><br><span class="line">        };</span><br><span class="line">        image.onerror = function() {</span><br><span class="line">            reject(new Error('Could not load image at' + url));</span><br><span class="line">        };</span><br><span class="line">        image.src = url;</span><br><span class="line">     });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><hr><p>这一部分题目我从网上收集来的一些练习题，几道编程题我自己第一遍做也觉得没那么好做，但是做完感觉获益匪浅，加深了我对 Promise 特性和如何更好使用 Promise 的理解。</p><p>所以 Promise 真正的学习，还是要结合具体场景实际开发运用。</p><p>Promise 功能看似简单，但认真整理却发现 Promise 内容确实挺多的，自己花了一整天时间去查阅、学习、理解、跑代码、然后整理 Promise 的笔记。</p><p>觉得有用 ？打赏给予鼓励，我会继续加油滴！！</p><!-- 样式代码 --><style>/* 渐变分割线 */hr {  border-image: linear-gradient(to right, #F00, #0F0 20%, #00F 80%, #000) 1 !important;}/* 首行缩进 */p {  text-indent:2em}</style>]]></content>
      
      
      <categories>
          
          <category> ES6精选文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重温ES6核心概念和基本用法</title>
      <link href="/2022/05/12/chong-wen-es6-he-xin-gai-nian-he-ji-ben-yong-fa/"/>
      <url>/2022/05/12/chong-wen-es6-he-xin-gai-nian-he-ji-ben-yong-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="ES6-新特性列表"><a href="#ES6-新特性列表" class="headerlink" title="ES6 新特性列表"></a>ES6 新特性列表</h2><hr><p>相比 ES5，ES6 提供了太多的更新，简单说来，主要为以下方面（大家可以依据自己不算清晰的点选择性查看本文）：</p><ul><li><p>Arrows,箭头函数</p></li><li><p>Classes，类</p></li><li><p>Enhanced object literals，增强的对象字面值</p></li><li><p>Template strings：模板字符串</p></li><li><p>Destructuring：解构</p></li><li><p>Default + rest + spread：参数默认值，rest 参数,扩展运算符</p></li><li><p>Let + const:命名声明的新方式</p></li><li><p>Iterators + for..of：遍历器</p></li><li><p>Generators：生成器</p></li><li><p>Unicode：更广泛的编码支持</p></li><li><p>Modules：语言层面上支持的模块机制</p></li><li><p>Module loaders：模块加载器</p></li><li><p>Map + set + weakmap + weakset：新的数据结构</p></li><li><p>Proxies：代理器</p></li><li><p>Symbols：新的基本类型，独一无二的值</p></li><li><p>Subclassable built-ins：类的继承</p></li><li><p>Promises：</p></li><li><p>Math + number + string + array + object apis：拓展了一些内置对象的方法</p></li><li><p>Binary and octal literals：二进制八进制字面量</p></li><li><p>Reflect api：操作对象的新 api</p></li><li><p>Tail calls:尾调用</p></li></ul><h3 id="Arrows-箭头函数"><a href="#Arrows-箭头函数" class="headerlink" title="Arrows 箭头函数"></a>Arrows 箭头函数</h3><hr><p>箭头函数使用类似于 =&gt;这样的语法定义函数，支持表达式模式和语句模式，不过其最大特点在于和父作用域具有一样的 this。我们知道普通函数的 this 既不指向函数自身也不指向函数的词法作用域，this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。使用箭头函数时再也不用担心 this 跳来跳去了。此外如果箭头函数如果定义在另一个函数里面，箭头函数会共享它父函数的 arguments 变量。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 表达式模式箭头函数</span><br><span class="line">var odds = evens.map(v =&gt; v + 1);</span><br><span class="line">var nums = evens.map((v, i) =&gt; v + i);</span><br><span class="line">var pairs = evens.map(v =&gt; ({even: v, odd: v + 1}));</span><br><span class="line"></span><br><span class="line">// 语句模式箭头函数</span><br><span class="line">nums.forEach(v =&gt; {</span><br><span class="line">  if (v % 5 === 0)</span><br><span class="line">    fives.push(v);</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">// 和父作用域具有相同的this</span><br><span class="line">var bob = {</span><br><span class="line">  _name: "Bob",</span><br><span class="line">  _friends: [],</span><br><span class="line">  printFriends() {</span><br><span class="line">    this._friends.forEach(f =&gt;</span><br><span class="line">      console.log(this._name + " knows " + f));</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function square() {</span><br><span class="line">  let example = () =&gt; {</span><br><span class="line">    let numbers = [];</span><br><span class="line">    for (let number of arguments) {</span><br><span class="line">      numbers.push(number * number);</span><br><span class="line">    }</span><br><span class="line">    return numbers;</span><br><span class="line">  };</span><br><span class="line">  return example();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">square(2, 4, 7.5, 8, 11.5, 21); // returns: [4, 16, 56.25, 64, 132.25, 441]</span><br></pre></td></tr></tbody></table></figure><h3 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h3><hr><p>JavaScript 中其实并不存在真正的类，ES6 的类其实是基于原型链模拟面向对象的一种语法糖。其本质上可以看做是构造函数的另一种写法。与真的类一样，它支持 super 继承，实例，静态方法和 constructor 方法。如果你也使用 React，工作中定义模块时一定没少写过 class A extends React.Component{}吧。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// 定义类</span><br><span class="line">class Point {</span><br><span class="line">  constructor(x, y) {</span><br><span class="line">    this.x = x;</span><br><span class="line">    this.y = y;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  toString() {</span><br><span class="line">    return '(' + this.x + ', ' + this.y + ')';</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 通过extends关键字实现继承</span><br><span class="line">class SkinnedMesh extends THREE.Mesh {</span><br><span class="line">  //constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。</span><br><span class="line">  //一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。</span><br><span class="line">  constructor(geometry, materials) {</span><br><span class="line">    // super表示父类的构造函数，用来新建父类的this对象,</span><br><span class="line">    // 子类必须在constructor方法中调用super方法，否则新建实例时会报错。如果不调用super方法，子类就得不到this对象。</span><br><span class="line">    super(geometry, materials);</span><br><span class="line"></span><br><span class="line">    //在构造方法中绑定this,可以防止实例找不到this</span><br><span class="line">    this.idMatrix = SkinnedMesh.defaultMatrix();</span><br><span class="line">    this.bones = [];</span><br><span class="line">    this.boneMatrices = [];</span><br><span class="line">    //...</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  // 非定义在this上的方法都会被直接定义在原型链上</span><br><span class="line">  update(camera) {</span><br><span class="line">    //...</span><br><span class="line">    // super在此处作为对象，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</span><br><span class="line">    super.update();</span><br><span class="line">  }</span><br><span class="line">  // 可以使用get和set关键字，对某个属性设置存值函数和取值函数</span><br><span class="line">  get boneCount() {</span><br><span class="line">  // 类的方法内部如果含有this，它默认指向类的实例</span><br><span class="line">    return this.bones.length;</span><br><span class="line">  }</span><br><span class="line">  set matrixType(matrixType) {</span><br><span class="line">    this.idMatrix = SkinnedMesh[matrixType]();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  // 加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用</span><br><span class="line">  static defaultMatrix() {</span><br><span class="line">    return new THREE.Matrix4();</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 类的所有实例共享一个原型对象</span><br><span class="line">let skin = new SkinnedMesh();</span><br><span class="line">// 静态方法需要直接通过类调用</span><br><span class="line">SkinnedMesh.defaultMatrix()</span><br></pre></td></tr></tbody></table></figure><h3 id="对象的拓展"><a href="#对象的拓展" class="headerlink" title="对象的拓展"></a>对象的拓展</h3><hr><ul><li>ES6 中对象的使用方法得以拓展，主要包括以下几点：</li><li>属性和方法可以简洁表示；</li><li>允许以表达式的模式定义属性名；</li><li>可以通过 _ _ proto _ _读取或设置当前对象的 prototype 对象;</li><li>使用 Object.is({},{})判断两个对象是否完全相对，类似于 ===;</li><li>Object.assign(target, source1, source2)合并对象；（浅拷贝）</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var obj = {</span><br><span class="line">    // __proto__用以设置当前对象的prototype对象，不推荐使用，推荐使用Object.setPrototypeOf()</span><br><span class="line">    __proto__: theProtoObj,</span><br><span class="line">    //‘handler:handler’可简写为handler（只需要写变量名就可以实现变量名为变量名，变量值为属性值）</span><br><span class="line">    handler,</span><br><span class="line">    // 简写在定义方法的时候同样有效</span><br><span class="line">    toString() {</span><br><span class="line">     // Super calls</span><br><span class="line">     return "d " + super.toString();</span><br><span class="line">    },</span><br><span class="line">    // 方括号内的表达式用以计算属性名</span><br><span class="line">    [ 'prop_' + (() =&gt; 42)() ]: 42</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><hr><p>模板字符串是一种组合字符串的语法糖，其使用类似于 Perl, Python 等语言的字符串修改方法类似，它的出现让我们拼合字符串时方便多了。目前相互中几乎所有字符串的拼接都用这个了，异常方便。</p><ul><li>模板字符串定义在两个反撇号中；</li><li>在模板字符串中可以直接换行，格式会得以保留；</li><li>通过 ${}可以很方便的在模板字符串中添加变量；</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 把字符串放在``(注意不是引号)中就可以使用</span><br><span class="line">`In JavaScript '\n' is a line-feed.`</span><br><span class="line"></span><br><span class="line">// 模板字符串保留了换行</span><br><span class="line">`In JavaScript this is</span><br><span class="line"> not legal.`</span><br><span class="line"></span><br><span class="line">// 在字符串中添加变量的方法，变量直接放在${}中即可</span><br><span class="line">var name = "Bob", time = "today";</span><br><span class="line">`Hello ${name}, how are you ${time}?`</span><br><span class="line"></span><br><span class="line">// 拼合请求时异常方便了</span><br><span class="line">POST`http://foo.org/bar?a=${a}&amp;b=${b}</span><br><span class="line">     Content-Type: application/json</span><br><span class="line">     X-Credentials: ${credentials}</span><br><span class="line">     { "foo": ${foo},</span><br><span class="line">       "bar": ${bar}}`(myOnReadyStateChangeHandler);</span><br></pre></td></tr></tbody></table></figure><h3 id="Destructuring-解构"><a href="#Destructuring-解构" class="headerlink" title="Destructuring 解构"></a>Destructuring 解构</h3><hr><p>解构使用模式匹配的方法绑定变量和值，数组和对象都可使用。解构在绑定失败的时会实现软绑定，即没有匹配值时，返回 undefined。使用方法可见示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 数组解构</span><br><span class="line">var [a, , b] = [1,2,3];</span><br><span class="line">// a = 1,b = 3</span><br><span class="line"></span><br><span class="line">// React中常见以下用法</span><br><span class="line">var {a, b, c} = this.props;</span><br><span class="line"></span><br><span class="line">// 对象解构也能用在函数的参数中</span><br><span class="line">function g({name: x}) {</span><br><span class="line">  console.log(x);</span><br><span class="line">}</span><br><span class="line">g({name: 5})</span><br><span class="line"></span><br><span class="line">// 绑定失败时返回undefined</span><br><span class="line">var [a] = [];</span><br><span class="line">a === undefined;</span><br><span class="line"></span><br><span class="line">// 解构时也可以绑定默认值</span><br><span class="line">var [a = 1] = [];</span><br><span class="line">a === 1;</span><br><span class="line"></span><br><span class="line">// 配合默认参数使用结构</span><br><span class="line">function r({x, y, w = 10, h = 10}) {</span><br><span class="line">  return x + y + w + h;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">r({x:1, y:2}) === 23</span><br></pre></td></tr></tbody></table></figure><h3 id="默认值，剩余值和拓展值"><a href="#默认值，剩余值和拓展值" class="headerlink" title="默认值，剩余值和拓展值"></a>默认值，剩余值和拓展值</h3><hr><ul><li>ES6 允许我们在给变量添加默认值</li><li>使用拓展值使得函数调用时可传入数组作为连续的参数</li><li>利用剩余值特性我们可以把函数尾部的参数转换为一个数组，现在使用 rest 就可以替换以前的 arguments 对象了。</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 给函数的参数添加默认值</span><br><span class="line">function f(x, y=12) {</span><br><span class="line">  // y is 12 if not passed (or passed as undefined)</span><br><span class="line">  return x + y;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 可以只传参数x的值了</span><br><span class="line">f(3) == 15</span><br><span class="line"></span><br><span class="line">// 使用rest</span><br><span class="line">function f(x, ...y) {</span><br><span class="line">  // y is an Array</span><br><span class="line">  return x * y.length;</span><br><span class="line">}</span><br><span class="line">f(3, "hello", true) == 6</span><br><span class="line"></span><br><span class="line">// 传入数组作为参数</span><br><span class="line">function f(x, y, z) {</span><br><span class="line">  return x + y + z;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 直接传入数组当作上面函数的参数</span><br><span class="line">f(...[1,2,3]) == 6</span><br></pre></td></tr></tbody></table></figure><h3 id="Let-和-Const"><a href="#Let-和-Const" class="headerlink" title="Let 和 Const"></a>Let 和 Const</h3><hr><p>ES6 新增了块作用域，新增了两种定义变量的方法，定义变量时推荐使用 let 替代 var， let 定义的变量在块作用域内有效， const 用以指定固定值，这两类新定义的变量不允许在定义前使用，也不允许重复定义。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function f() {</span><br><span class="line">  {</span><br><span class="line">    let x;</span><br><span class="line">    {</span><br><span class="line">      const x = "sneaky";</span><br><span class="line">      // 改变const</span><br><span class="line">      x = "foo";</span><br><span class="line">    }</span><br><span class="line">    // 重复定义会出错</span><br><span class="line">    let x = "inner";</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 在这里想到一个使用var时新手特别容易犯的问题</span><br><span class="line">for (var i=0; i&lt;10; ++i) {</span><br><span class="line">    setTimeout(function(){</span><br><span class="line">        console.log(i);</span><br><span class="line">    }, i*1000);</span><br><span class="line">}</span><br><span class="line">// 使用var 所有的结果都是10</span><br><span class="line">// 使用let 结果就是预想要的结果</span><br><span class="line">for (let i=0; i&lt;10; ++i) {</span><br><span class="line">    setTimeout(function(){</span><br><span class="line">        console.log(i);</span><br><span class="line">    }, i*1000);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Iterators-For-Of"><a href="#Iterators-For-Of" class="headerlink" title="Iterators + For..Of"></a>Iterators + For..Of</h3><hr><p>ES6 为部署了 Iterator 接口的各种不同的数据结构提供了统一的访问机制。其本质是一个指针对象。每次调用 next 方法，可以把指针指向数据结构的下一个成员。具体说来，每一次调用 next 方法，都会返回数据结构的当前成员的信息（一个包含 value 和 done 两个属性的对象，value 属性是当前成员的值，done 属性是一个布尔值，表示遍历是否结束）。</p><p>凡是部署了 Symbol.iterator 属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">let fibonacci = {</span><br><span class="line">  // 一个数据结构只要具有Symbol.iterator属性，就可被认为是可遍历的，`Symbol.iterator`是一个表达式，返回Symbol对象的iterator属性，所以需要放在[]中，本质上它是当前数据结构的遍历器生成函数。</span><br><span class="line"></span><br><span class="line">  [Symbol.iterator]() {</span><br><span class="line">    let pre = 0, cur = 1;</span><br><span class="line">    return {</span><br><span class="line">      next() {</span><br><span class="line">        [pre, cur] = [cur, pre + cur];</span><br><span class="line">        return { done: false, value: cur }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// fibonacci部署了Symbol.iterator属性，只要done不为true就会一直遍历</span><br><span class="line">for (var n of fibonacci) {</span><br><span class="line">// 调用1000以内的值做遍历</span><br><span class="line">  if (n &gt; 1000)</span><br><span class="line">    break;</span><br><span class="line">  console.log(n);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>原生具备 Iterator 接口的数据结构有以下几种:数组、某些类似数组的对象（字符串、DOM NodeList 对象、arguments 对象）、Set 和 Map 结构。</p><p>对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动在 Symbol.iterator 的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。</p><p>注意：实际使用时需引入 polyfill</p><h3 id="Generators"><a href="#Generators" class="headerlink" title="Generators"></a>Generators</h3><hr><p>可以从两个角度理解 Generators，它既是状态机也是一个遍历器对象生成函数。执行该函数可以理解为启动了遍历器，之后每次执行 next()函数则每次执行到 yield 处。</p><p>值得注意的是执行 next()时可添加参数，这实现了在函数运行的不同阶段，可以从外部向内部注入不同的值，</p><p>生成器使用 function<em>和 yield 简化了迭代过程，使用 function</em>定义的函数返回了一个生成器实例。生成器是迭代器的子类，但是包含 next 和 throw。这使得值可以回流到生成器， yield 是一个可以返回值的表达式。</p><p>for…of 循环可以自动遍历 Generator 函数时生成的 Iterator 对象，此时不再需要调用 next 方法。</p><p>Generator 的 return 方法会返回固定的值，终结遍历 Generator 函数。返回值的 value 属性就是 return 方法的参数，返回值的 done 属性为 true。</p><p>结合 co 模块可以实现比 Promise 更加优雅的异步调用方式</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 使用generator函数实现上述遍历器对象</span><br><span class="line">var fibonacci = {</span><br><span class="line">  [Symbol.iterator]: function*() {</span><br><span class="line">    var pre = 0, cur = 1;</span><br><span class="line">    for (;;) {</span><br><span class="line">      var temp = pre;</span><br><span class="line">      pre = cur;</span><br><span class="line">      cur += temp;</span><br><span class="line">      yield cur;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">for (var n of fibonacci) {</span><br><span class="line">  // truncate the sequence at 1000</span><br><span class="line">  if (n &gt; 1000)</span><br><span class="line">    break;</span><br><span class="line">  console.log(n);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 使用co模块（基于 Promise 对象的自动执行器），可以实现异步函数的自动执行</span><br><span class="line">var gen = function* () {</span><br><span class="line">  var f1 = yield somethingAsync();</span><br><span class="line">  var f2 = yield anotherThingAsync();</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">var co = require('co');</span><br><span class="line">co(gen);</span><br></pre></td></tr></tbody></table></figure><p>注意：实际使用时需引入 polyfill</p><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><hr><p>ES6 完整支持所有的 Unicode,包括新的 Unicode 字面量和 u 模式正则，提供了新的 API 来处理 21bit 级别的字符串。这些新加特性使得我们的 JavaScript 应用有能力支持各种语言。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// same as ES5.1</span><br><span class="line">"𠮷".length == 2</span><br><span class="line"></span><br><span class="line">// 新的正则匹配模式</span><br><span class="line">"𠮷".match(/./u)[0].length == 2</span><br><span class="line"></span><br><span class="line">// 新形式</span><br><span class="line">"\u{20BB7}"=="𠮷"=="\uD842\uDFB7"</span><br><span class="line"></span><br><span class="line">// codePointAt()能够正确处理4个字节储存的字符，返回一个字符的码点</span><br><span class="line">"𠮷".codePointAt(0) == 0x20BB7</span><br><span class="line"></span><br><span class="line">// for-of 遍历字符，以整体输出</span><br><span class="line">for(var c of "𠮷") {</span><br><span class="line">  console.log(c);</span><br><span class="line">}</span><br><span class="line">// 𠮷</span><br></pre></td></tr></tbody></table></figure><h3 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h3><hr><p>现代 JS 应用的开发离不开模块了，ES6 对模块的定义提供了语言层面的支持。规范化了各种 JavaScript 模块加载器，支持运行时动态加载模块，支持异步加载模块。</p><p>ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量，效率要比 CommonJS 模块的加载方式高。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// lib/math.js 模块的定义</span><br><span class="line">export function sum(x, y) {</span><br><span class="line">  return x + y;</span><br><span class="line">}</span><br><span class="line">export var pi = 3.141593;</span><br><span class="line"></span><br><span class="line">// app.js 模块的全部引用</span><br><span class="line">import * as math from "lib/math";</span><br><span class="line">alert("2π = " + math.sum(math.pi, math.pi));</span><br><span class="line"></span><br><span class="line">// otherApp.js 模块的部分引用</span><br><span class="line">import {sum, pi} from "lib/math";</span><br><span class="line">alert("2π = " + sum(pi, pi));</span><br><span class="line"></span><br><span class="line">// 模块导出方法</span><br><span class="line">// lib/mathplusplus.js</span><br><span class="line">export * from "lib/math";</span><br><span class="line">export var e = 2.71828182846;</span><br><span class="line">export default function(x) {</span><br><span class="line">    return Math.log(x);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 混合引入方法</span><br><span class="line">import ln, {pi, e} from "lib/mathplusplus";</span><br><span class="line">alert("2π = " + ln(e)*pi*2);</span><br></pre></td></tr></tbody></table></figure><h3 id="Module-Loaders（其实并非-ES6-标准的一部分，只是草案）"><a href="#Module-Loaders（其实并非-ES6-标准的一部分，只是草案）" class="headerlink" title="Module Loaders（其实并非 ES6 标准的一部分，只是草案）"></a>Module Loaders（其实并非 ES6 标准的一部分，只是草案）</h3><hr><ul><li>模块加载器支持以下功能：</li><li>动态加载</li><li>状态隔离</li><li>全局命名空间隔离</li><li>编写钩子</li><li>嵌套</li></ul><p>默认的模块加载器可以被配置，新的加载器可以被配置来评估加载独立上下文中的内容。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 动态加载 – ‘System’ 是默认的加载器</span><br><span class="line">System.import('lib/math').then(function(m) {</span><br><span class="line">  alert("2π = " + m.sum(m.pi, m.pi));</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">// 新的加载器创建了执行沙盒</span><br><span class="line">var loader = new Loader({</span><br><span class="line">  global: fixup(window) // replace ‘console.log’</span><br><span class="line">});</span><br><span class="line">loader.eval("console.log('hello world!');");</span><br><span class="line"></span><br><span class="line">// 可以直接修改模块的缓存</span><br><span class="line">System.get('jquery');</span><br><span class="line">System.set('jquery', Module({$: $})); // WARNING: not yet finalized</span><br></pre></td></tr></tbody></table></figure><h3 id="Map-Set-WeakMap-WeakSet"><a href="#Map-Set-WeakMap-WeakSet" class="headerlink" title="Map Set WeakMap WeakSet"></a>Map Set WeakMap WeakSet</h3><hr><p>ES6 为算法提供了新的高效的数据结构， WeakMaps 提供了防泄漏的键值对表。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// Set类似于数组，但是成员的值都是唯一的，没有重复的值。</span><br><span class="line">var s = new Set();</span><br><span class="line">s.add("hello").add("goodbye").add("hello");</span><br><span class="line">s.size === 2;</span><br><span class="line">s.has("hello") === true;</span><br><span class="line"></span><br><span class="line">// Map 类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</span><br><span class="line">var m = new Map();</span><br><span class="line">m.set("hello", 42);</span><br><span class="line">m.set(s, 34);</span><br><span class="line">m.get(s) == 34;</span><br><span class="line"></span><br><span class="line">// WeakMap结构与Map结构类似，也是用于生成键值对的集合，但是WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名，此外WeakMap的键名所指向的对象，不计入垃圾回收机制。</span><br><span class="line">var wm = new WeakMap();</span><br><span class="line">wm.set(s, { extra: 42 });</span><br><span class="line">wm.size === undefined</span><br><span class="line"></span><br><span class="line">// WeakSet 结构与 Set 类似，也是不重复的值的集合,但是WeakSet 的成员只能是对象，而不能是其他类型的值，此外WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用</span><br><span class="line">var ws = new WeakSet();</span><br><span class="line">ws.add({ data: 42 });</span><br><span class="line">// Because the added object has no other references, it will not be held in the set</span><br></pre></td></tr></tbody></table></figure><p>注意：实际使用时需引入 polyfill</p><h3 id="Proxies"><a href="#Proxies" class="headerlink" title="Proxies"></a>Proxies</h3><hr><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p><p>可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p><p>需要注意的是目前未被 Babel 支持，使用时需谨慎</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// target参数表示所要拦截的目标对象;</span><br><span class="line">var target = {};</span><br><span class="line"></span><br><span class="line">// handler参数也是一个对象，用来定制拦截行为;</span><br><span class="line">var handler = {</span><br><span class="line">  get: function (receiver, name) {</span><br><span class="line">    return `Hello, ${name}!`;</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">// 生成一个Proxy实例</span><br><span class="line">var p = new Proxy(target, handler);</span><br><span class="line">p.world === 'Hello, world!';</span><br><span class="line"></span><br><span class="line">// 对函数同样可以使用代理</span><br><span class="line">var target = function () { return 'I am the target'; };</span><br><span class="line">var handler = {</span><br><span class="line">  apply: function (receiver, ...args) {</span><br><span class="line">    return 'I am the proxy';</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">var p = new Proxy(target, handler);</span><br><span class="line">p() === 'I am the proxy';</span><br></pre></td></tr></tbody></table></figure><p>// Proxy 支持的拦截操作如下</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var handler =</span><br><span class="line">{</span><br><span class="line">  get:...,</span><br><span class="line">  set:...,</span><br><span class="line">  has:...,</span><br><span class="line">  deleteProperty:...,</span><br><span class="line">  apply:...,</span><br><span class="line">  construct:...,</span><br><span class="line">  getOwnPropertyDescriptor:...,</span><br><span class="line">  defineProperty:...,</span><br><span class="line">  getPrototypeOf:...,</span><br><span class="line">  setPrototypeOf:...,</span><br><span class="line">  enumerate:...,</span><br><span class="line">  ownKeys:...,</span><br><span class="line">  preventExtensions:...,</span><br><span class="line">  isExtensible:...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意：Babel 不支持，使用时应注意</p><h3 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h3><hr><p>Symbol 保证每个属性的名字都是独一无二的，这样就从根本上防止了属性名的冲突；它是一种类似于字符串的数据类型,Symbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述；Symbols 是唯一的，单并非私有的，通过 Object.getOwnPropertySymbols 可以获取对应的值；Symbol 值作为对象属性名时，不能用点运算符。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var MyClass = (function() {</span><br><span class="line">  // module scoped symbol</span><br><span class="line">  var key = Symbol("key");</span><br><span class="line"></span><br><span class="line">  function MyClass(privateData) {</span><br><span class="line">    this[key] = privateData;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  MyClass.prototype = {</span><br><span class="line">    doStuff: function() {</span><br><span class="line">      ... this[key] ...</span><br><span class="line">    }</span><br><span class="line">  };</span><br><span class="line">  return MyClass;</span><br><span class="line">})();</span><br><span class="line"></span><br><span class="line">var c = new MyClass("hello")</span><br><span class="line">c["key"] === undefined</span><br></pre></td></tr></tbody></table></figure><p>由于语言限制，Babel 只提供部分支持，使用时需要注意</p><h3 id="内置类的继承"><a href="#内置类的继承" class="headerlink" title="内置类的继承"></a>内置类的继承</h3><hr><p>在 ES6 中，内置的 Array, Date, DOM Element 可以被继承以拓展了。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// User code of Array subclass</span><br><span class="line">class MyArray extends Array {</span><br><span class="line">    constructor(...args) { super(...args);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var arr = new MyArray();</span><br><span class="line">arr[1] = 12;</span><br><span class="line">arr.length == 2</span><br></pre></td></tr></tbody></table></figure><p>注意：babel 部分支持，由于 ES5 引擎的限制 Date, Array, Error 不被支持，但是 HTMLElement 是被支持的</p><h3 id="Math-Number-String-Array-Object-APIs"><a href="#Math-Number-String-Array-Object-APIs" class="headerlink" title="Math + Number + String + Array + Object APIs"></a>Math + Number + String + Array + Object APIs</h3><hr><p>ES6 为很多旧有对象添加了新的 API，这些对象包括 Math, Array 器， String, Object，如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Number.EPSILON</span><br><span class="line">Number.isInteger(Infinity) // false</span><br><span class="line">Number.isNaN("NaN") // false</span><br><span class="line"></span><br><span class="line">Math.acosh(3) // 1.762747174039086</span><br><span class="line">Math.hypot(3, 4) // 5</span><br><span class="line">Math.imul(Math.pow(2, 32) - 1, Math.pow(2, 32) - 2) // 2</span><br><span class="line"></span><br><span class="line">"abcde".includes("cd") // true</span><br><span class="line">"abc".repeat(3) // "abcabcabc"</span><br><span class="line"></span><br><span class="line">Array.from(document.querySelectorAll('*')) // Returns a real Array</span><br><span class="line">Array.of(1, 2, 3) // Similar to new Array(...), but without special one-arg behavior</span><br><span class="line">[0, 0, 0].fill(7, 1) // [0,7,7]</span><br><span class="line">[1, 2, 3].find(x =&gt; x == 3) // 3</span><br><span class="line">[1, 2, 3].findIndex(x =&gt; x == 2) // 1</span><br><span class="line">[1, 2, 3, 4, 5].copyWithin(3, 0) // [1, 2, 3, 1, 2]</span><br><span class="line">["a", "b", "c"].entries() // iterator [0, "a"], [1,"b"], [2,"c"]</span><br><span class="line">["a", "b", "c"].keys() // iterator 0, 1, 2</span><br><span class="line">["a", "b", "c"].values() // iterator "a", "b", "c"</span><br><span class="line"></span><br><span class="line">Object.assign(Point, { origin: new Point(0,0) })</span><br></pre></td></tr></tbody></table></figure><p>babel 通过 polyfill 提供部分支持</p><h3 id="二进制和八进制字面量"><a href="#二进制和八进制字面量" class="headerlink" title="二进制和八进制字面量"></a>二进制和八进制字面量</h3><hr><p>ES6 添加了二进制和八进制数值的字面量定义方法：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0b111110111 === 503 // true</span><br><span class="line">0o767 === 503 // true</span><br></pre></td></tr></tbody></table></figure><p>babel 只支持字面量形式，不支持 Number(“0o767”)形式</p><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><hr><p>Promise 为异步编程提供了一种新的方式，Promise 把未来将用到的值当做一等对象，Promise 在很多前端库中已经有所支持了。这个平时用得最多了，还没使用的推荐试试。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function timeout(duration = 0) {</span><br><span class="line">    return new Promise((resolve, reject) =&gt; {</span><br><span class="line">        setTimeout(resolve, duration);</span><br><span class="line">    })</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var p = timeout(1000).then(() =&gt; {</span><br><span class="line">    return timeout(2000);</span><br><span class="line">}).then(() =&gt; {</span><br><span class="line">    throw new Error("hmm");</span><br><span class="line">}).catch(err =&gt; {</span><br><span class="line">    return Promise.all([timeout(100), timeout(200)]);</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>实际使用时需引入 polyfill</p><h3 id="Reflect-API"><a href="#Reflect-API" class="headerlink" title="Reflect API"></a>Reflect API</h3><hr><p>Reflect 对象与 Proxy 对象一样，也是 ES6 为了操作对象而提供的新 API，作用如下：</p><ul><li>将 Object 对象的一些明显属于语言内部的方法（比如 Object.defineProperty），放到 Reflect 对象上；</li><li>修改某些 Object 方法的返回结果，让其变得更合理；</li><li>让 Object 操作都变成函数行为，比如 name in obj 和 delete obj[name]，而 Reflect.has(obj, name)和 Reflect.deleteProperty(obj, name)让它们变成了函数行为。</li><li>Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法；</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var O = {a: 1};</span><br><span class="line">Object.defineProperty(O, 'b', {value: 2});</span><br><span class="line">O[Symbol('c')] = 3;</span><br><span class="line"></span><br><span class="line">Reflect.ownKeys(O); // ['a', 'b', Symbol(c)]</span><br><span class="line"></span><br><span class="line">function C(a, b){</span><br><span class="line">  this.c = a + b;</span><br><span class="line">}</span><br><span class="line">var instance = Reflect.construct(C, [20, 22]);</span><br><span class="line">instance.c; // 42</span><br></pre></td></tr></tbody></table></figure><p>实际使用时需引入 polyfill</p><h3 id="Tail-Calls"><a href="#Tail-Calls" class="headerlink" title="Tail Calls"></a>Tail Calls</h3><hr><p>尾部调用被保证不能无限拓展栈，这让有无限制输入时的递归算法更加安全。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function factorial(n, acc = 1) {</span><br><span class="line">    'use strict';</span><br><span class="line">    if (n &lt;= 1) return acc;</span><br><span class="line">    return factorial(n - 1, n * acc);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 堆栈越来越常用，在ES6中其使用更加安全了</span><br><span class="line">factorial(100000)</span><br></pre></td></tr></tbody></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>上文对 ES6 的新特性都做了简单的描述，但是关于 Reflect API 和 Proxies,由于本人对他们的理解还不够透彻，说得可能有些不清不楚。希望阅读本文让你有收获，有任何疑问，大家也可以一起讨论。</p><p>原文：<a href="https://segmentfault.com/a/1190000009885614">https://segmentfault.com/a/1190000009885614</a></p>  <!-- 样式代码 -->  <style>  /* 渐变分割线 */  hr {    border-image: linear-gradient(to right, #F00, #0F0 20%, #00F 80%, #000) 1 !important;  }  /* 首行缩进 */  p {    text-indent:2em;    font-size: 19px;  }  /* 文章默认字体 */  #articleContent p {    font-size: 1.1em;  }</style>]]></content>
      
      
      <categories>
          
          <category> ES6精选文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello word</title>
      <link href="/2022/05/10/hello-world/"/>
      <url>/2022/05/10/hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 启动hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 默认 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>劝学</title>
      <link href="/2022/05/10/quan-xue/"/>
      <url>/2022/05/10/quan-xue/</url>
      
        <content type="html"><![CDATA[<h2 id="第一段"><a href="#第一段" class="headerlink" title="第一段"></a>第一段</h2><p>君子曰：学不可以已。<span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><h2 id="第二段"><a href="#第二段" class="headerlink" title="第二段"></a>第二段</h2><p>青，取之于蓝，而青于蓝；冰，水为之，而寒于水。木直中绳，𫐓以为轮，其曲中规。虽有槁暴，不复挺者，𫐓使之然也。故木受绳则直，金就砺则利，君子博学而日参省乎己，则知明而行无过矣。</p><h2 id="第三段"><a href="#第三段" class="headerlink" title="第三段"></a>第三段</h2><p>故不登高山，不知天之高也；不临深溪，不知地之厚也；不闻先王之遗言，不知学问之大也。干、越、夷、貉之子，生而同声，长而异俗，教使之然也。诗曰：“嗟尔君子，无恒安息。靖共尔位，好是正直。神之听之，介尔景福。”神莫大于化道，福莫长于无祸。（此段教材无）</p><h2 id="第四段"><a href="#第四段" class="headerlink" title="第四段"></a>第四段</h2><p>吾尝终日而思矣，不如须臾之所学也；吾尝跂而望矣，不如登高之博见也。登高而招，臂非加长也，而见者远；顺风而呼，声非加疾也，而闻者彰。假舆马者，非利足也，而致千里；假舟楫者，非能水也，而绝江河。君子生非异也，善假于物也。</p><p>南方有鸟焉，名曰蒙鸠，以羽为巢，而编之以发，系之苇苕，风至苕折，卵破子死。巢非不完也，所系者然也。西方有木焉，名曰射干，茎长四寸，生于高山之上，而临百仞之渊，木茎非能长也，所立者然也。蓬生麻中，不扶而直；白沙在涅，与之俱黑。兰槐之根是为芷，其渐之滫，君子不近，庶人不服。其质非不美也，所渐者然也。故君子居必择乡，游必就士，所以防邪辟而近中正也。</p><p>物类之起，必有所始。荣辱之来，必象其德。肉腐出虫，鱼枯生蠹。怠慢忘身，祸灾乃作。强自取柱，柔自取束。邪秽在身，怨之所构。施薪若一，火就燥也，平地若一，水就湿也。草木畴生，禽兽群焉，物各从其类也。是故质的张，而弓矢至焉；林木茂，而斧斤至焉；树成荫，而众鸟息焉。醯酸，而蚋聚焉。故言有招祸也，行有招辱也，君子慎其所立乎！（此段教材无）</p><p>积土成山，风雨兴焉；积水成渊，蛟龙生焉；积善成德，而神明自得，圣心备焉。故不积跬步，无以至千里；不积小流，无以成江海。骐骥一跃，不能十步；驽马十驾，功在不舍。锲而舍之，朽木不折；锲而不舍，金石可镂。蚓无爪牙之利，筋骨之强，上食埃土，下饮黄泉，用心一也。蟹六跪而二螯，非蛇鳝之穴无可寄托者，用心躁也。</p><p>是故无冥冥之志者，无昭昭之明；无惛惛之事者，无赫赫之功。行衢道者不至，事两君者不容。目不能两视而明，耳不能两听而聪。螣蛇无足而飞，鼫鼠五技而穷。《诗》曰：“尸鸠在桑，其子七兮。淑人君子，其仪一兮。其仪一兮，心如结兮！”故君子结于一也。</p><p>昔者瓠巴鼓瑟，而流鱼出听；伯牙鼓琴，而六马仰秣。故声无小而不闻，行无隐而不形。玉在山而草木润，渊生珠而崖不枯。为善不积邪？安有不闻者乎？</p><p>学恶乎始？恶乎终？曰：其数则始乎诵经，终乎读礼；其义则始乎为士，终乎为圣人，真积力久则入，学至乎没而后止也。故学数有终，若其义则不可须臾舍也。为之，人也；舍 之，禽兽也。故书者，政事之纪也；诗者，中声之所止也；礼者，法之大分，类之纲纪也。故学至乎礼而止矣。夫是之谓道德之极。礼之敬文也，乐之中和也，诗书之博也，春秋之微 也，在天地之间者毕矣。君子之学也，入乎耳，着乎心，布乎四体，形乎动静。端而言，蝡而动，一可以为法则。小人之学也，入乎耳，出乎口；口耳之间，则四寸耳，曷足以美七尺之躯哉！古之学者为己，今之学者为人。君子之学也，以美其身；小人之学也，以为禽犊。故不问而告谓之傲，问一而告二谓之囋。傲、非也，囋、非也；君子如向矣。</p><p>学莫便乎近其人。礼乐法而不说，诗书故而不切，春秋约而不速。方其人之习君子之说，则尊以遍矣，周于世矣。故曰：学莫便乎近其人。</p><p>学之经莫速乎好其人，隆礼次之。上不能好其人，下不能隆礼，安特将学杂识志，顺诗书而已耳。则末世穷年，不免为陋儒而已。将原先王，本仁义，则礼正其经纬蹊径也。若挈裘领，诎五指而顿之，顺者不可胜数也。不道礼宪，以诗书为之，譬之犹以指测河也，以戈舂黍也，以锥餐壶也，不可以得之矣。故隆礼，虽未明，法士也；不隆礼，虽察辩，散儒也。</p><p>问楛者，勿告也；告楛者，勿问也；说楛者，勿听也。有争气者，勿与辩也。故必由其道至，然后接之；非其道则避之。故礼恭，而后可与言道之方；辞顺，而后可与言道之理；色从而后可与言道之致。故未可与言而言，谓之傲；可与言而不言，谓之隐；不观气色而言，谓瞽。故君子不傲、不隐、不瞽，谨顺其身。诗曰：“匪交匪舒，天子所予。”此之谓也。</p><p>百发失一，不足谓善射；千里蹞步不至，不足谓善御；伦类不通，仁义不一，不足谓善学。学也者，固学一之也。一出焉，一入焉，涂巷之人也；其善者少，不善者多，桀纣盗跖也；全之尽之，然后学者也。</p><p>君子知夫不全不粹之不足以为美也，故诵数以贯之，思索以通之，为其人以处之，除其害者以持养之。使目非是无欲见也，使耳非是无欲闻也，使口非是无欲言也，使心非是无欲虑也。及至其致好之也，目好之五色，耳好之五声，口好之五味，心利之有天下。是故权利不能倾也，群众不能移也，天下不能荡也。生乎由是，死乎由是，夫是之谓德操。德操然后能定，能定然后能应。能定能应，夫是之谓成人。天见其明，地见其光，君子贵其全也。</p>]]></content>
      
      
      <categories>
          
          <category> 文言文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 激励 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
